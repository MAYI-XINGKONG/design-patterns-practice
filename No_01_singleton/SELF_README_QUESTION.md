### I、关于使用静态内部类实现单例模式，它具体是怎么实现的呢？哇 好奇，难受！

#### 一、首先静态内部类实现的单例模式是怎么保证只创建一个实例的呢？(了解即可，奉献给那些好奇到发烧的同学)

请看大屏幕 啊呸...   请看下面的示例：

```java
public class Singleton {
    // 私有构造方法，防止外部实例化
    private Singleton() {}
  
    // 静态内部类，持有单例实例
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
  
    // 公共访问点，获取单例实例
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

##### 1、首先是类加载机制的唯一性

###### JVM的类加载机制

> `Java`类的加载是由 `ClassLoader`负责，且 `JVM`会确保每个类(用全限定类名进行标识)在整个应用程序/项目中仅被加载一次
>
> 当首次调用 `getInstance()`方法时，会触发静态内部类 `SingletonHolder`的加载和初始化
>
> 这个时候 `JVM`会检查这个类是否已经被加载，没有则执行初始化操作(创建 `INSTANCE`实例)
>
> 这个过程是具有唯一性的

###### <clinit>方法的线程安全初始化

> 静态内部类的静态成员 `INSTANCE`的初始化由 `JVM`自动生成的 `<clinit>(类构造)`方法完成
>
> `JVM`规范有规定，该方法在多线程环境下会自动加锁同步，确保无论多少线程同时尝试加载SingletonHolder类，有且只有一个线程可以执行初始化逻辑，其他线程会被阻塞直到初始化完成
>
> 这就从根本上避免了多线程环境下的实例重复创建问题

##### 2、然后是静态成员的内存唯一性

###### 静态变量的存储特性

> 静态变量存储在 `JVM`的方法区(Method Area),且每个类的静态变量在内存中有且只有一份副本!
>
> 当 `SingletonHolder`类被加载时，`INSTANCE`会被初始化并存储到方法区，后续所有对 `SingletonHolder.INSTANCE`的访问都会指向同一个内存地址
>
> 所以无法创建多个实例

###### `final`关键字的不可变性

> 代码中 `INSTANCE`被声明为 `final`,就是说其引用一旦指向 `Singleton`实例后就不能再修改
>
> 即使存在其他线程尝试修改(虽然不可能),`final`关键字也能保证其引用的唯一性，避免实例被覆盖或替换掉

##### 3、私有构造方法的访问限制

###### 阻止外部直接实例化

> `Singleton`类的构造方法被声明为 `private`,外部类无法通过 `new Singleton()`直接创建实例
>
> 唯一可能创建实例的地方是 `SingletonHolder`类的静态初始化块 `new Singleton()`,但是该操作只在类加载的时候执行一次，后续也没有其他途径可以调用构造方法(反射？就知道你会这么说...)

###### 防止反射破坏单例

> 若通过反射强行调用私有构造方法，需额外处理(比如你需要在构造方法中先检查实例是否已存在),但静态内部类实现方式已通过类加载机制避免了反射导致的重复实例化(除非你刻意绕过类加载机制，这在常规场景中特别少见👽👽👽)

##### 4、总结时间到

| 保障维度               | 实现方式                                                      | 作用                               |
| ---------------------- | ------------------------------------------------------------- | ---------------------------------- |
| **类加载机制**   | `JVM`确保静态内部类只加载一次，`<clinit>`方法自动加锁同步 | 避免多线程下的重复初始化           |
| **静态成员特性** | 静态变量在方法区唯一存储，`final`关键字保证引用不可变       | 确保实例内存地址的唯一性           |
| **访问控制**     | 使用私有构造方法阻止外部实例化                                | 切断除类加载以外的所有实例创建途径 |

#### 二、静态内部类实现的单例模式为什么具备高性能、延迟加载和线程安全等特点呢？(了解)

* [X] 高性能

> 在静态内部类实现的单例模式里，实例的初始化操作只会执行一次
>
> 一旦实例被创建，后续调用 `getInstance()`方法时，就直接返回已存在的实例，不用再进行同步操作
>
> 和传统的懒汉式单例模式(每次获取实例都需要加锁)以及饿汉式单例模式(类加载时就初始化实例)相比，这种方式避免了不必要的同步开销和提前初始化带来的资源浪费，所以性能相对更高

* [X] 延迟加载

> 静态内部类不会在外部类加载时就被初始化，而是要等到第一次调用 `getInstance()`方法时，才会触发内部类的加载并创建实例
>
> 这样就实现了延迟加载的效果，也就是说，单例实例是在真正被使用的时候才会被创建，而不是在类加载阶段就创建，从而节省了系统资源

* [X] 线程安全

> Java 语言有规定，类的静态属性只会在第一次加载类的时候进行初始化
>
> 并且 `JVM `会确保一个类的 `<clinit>()` 方法在多线程环境下能够被正确的加锁和同步
>
> 在静态内部类实现的单例模式中，实例是作为静态常量存放在静态内部类中的(看实例代码)
>
> 当第一次调用 `getInstance()` 方法加载内部类时，`JVM` 会确保内部类的初始化过程是线程安全的，进而保证单例实例的创建也是线程安全的

* [X] 总结时间到

* 由于实例的创建过程没有使用同步关键字，在实例创建完成之后，调用 `getInstance()`方法不会产生任何同步开销，这就保证了高性能
* 当 `Singleton`类被加载时，`SingletonHolder`类并不会被加载，这就保证了延迟加载
* 只有当第一次调用 `getInstance()`方法时，`SingletonHolder`类才会被加载，此时静态常量 `INSTANCE`会被初始化，而且 `JVM`会保证这个初始化过程是线程安全的，这就保证了线程安全

---

